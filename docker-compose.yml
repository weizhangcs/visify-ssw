services:
  db:
    image: postgres:16
    container_name: vss-db
    volumes:
      - postgres_data:/var/lib/postgresql/data/
      - ./configs/postgres/init-dbs.sql:/docker-entrypoint-initdb.d/init-dbs.sql
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -d $${POSTGRES_DB} -U $${POSTGRES_USER}"]
      start_period: 20s
      interval: 30s
      retries: 5
      timeout: 5s
    environment:
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    container_name: vss-redis
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "redis-cli ping | grep PONG"]
      start_period: 20s
      interval: 30s
      retries: 5
      timeout: 3s
    expose:
      - "6379"

  web:
    #build: .
    image: ghcr.io/weizhangcs/vss-workbench:v1.0.0
    container_name: vss-web
    command: python manage.py runserver 0.0.0.0:8000
    volumes:
      - .:/app
    ports:
      - "8000:8000"
    environment: &django_env
      # Django & Postgres & Celery
      - DJANGO_SETTINGS_MODULE=visify_ssw.settings
      - DJANGO_SECRET_KEY=${DJANGO_SECRET_KEY}
      - DJANGO_DEBUG=${DJANGO_DEBUG}
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - CELERY_BROKER_URL=redis://redis:6379/0
      # --- vvvvvv 核心修改：内外地址分离 vvvvvv ---
      # 内部服务间通信地址 (使用服务名)
      - LABEL_STUDIO_URL=http://label-studio:8080
      - SUBEDITOR_URL=http://subeditor:3000

      # 外部浏览器访问地址 (使用 localhost 和映射的端口)
      - LABEL_STUDIO_PUBLIC_URL=${LABEL_STUDIO_PUBLIC_URL}
      - SUBEDITOR_PUBLIC_URL=${SUBEDITOR_PUBLIC_URL}
      - LOCAL_MEDIA_URL_BASE=${LOCAL_MEDIA_URL_BASE}
      # --- ^^^^^^ 核心修改：内外地址分离 ^^^^^^ ---
      # 存储后端开关与配置
      - STORAGE_BACKEND=${STORAGE_BACKEND}
      - LOCAL_MEDIA_URL_BASE=${LOCAL_MEDIA_URL_BASE}
      # AWS S3 (即使在local模式下也传递)
      - AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
      - AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
      - AWS_STORAGE_BUCKET_NAME=${AWS_STORAGE_BUCKET_NAME}
      - AWS_S3_REGION_NAME=${AWS_S3_REGION_NAME}
      - AWS_S3_CUSTOM_DOMAIN=${AWS_S3_CUSTOM_DOMAIN}
    depends_on:
      - db
      - redis

  celery_worker:
    #build: .
    image: ghcr.io/weizhangcs/vss-workbench:v1.0.0
    container_name: vss-celery-worker
    command: celery -A visify_ssw worker -l info
    volumes:
      - .:/app
    environment: *django_env
    depends_on:
      - web

  nginx_media_server:
    image: nginx:1.25-alpine
    container_name: vss-nginx-media
    ports:
      - "9999:80"
    volumes:
      - ./configs/nginx/vss-media-server.conf:/etc/nginx/conf.d/default.conf:ro
      - ./media_root:/var/www/media_root:ro

  subeditor:
    image: ghcr.io/weizhangcs/vss-subeditor:v1.0.0
    container_name: vss-subeditor
    ports:
      - "3000:3000"
    # 注意：因为我们使用了生产构建，热重载不再有效
    # 如果需要修改前端代码，需要重新构建此服务

  label-studio:
    image: heartexlabs/label-studio:latest
    container_name: vss-label-studio
    ports:
      - "8081:8080"
    volumes:
      - label_studio_data:/label-studio/data
      - ./configs/nginx/nginx-ls.conf:/etc/nginx/nginx.conf:ro # 使用专用的Nginx配置文件
    environment:
      - LABEL_STUDIO_ALLOW_LEGACY_TOKEN_AUTH=true
      - LABEL_STUDIO_HOST=http://localhost:8081 # 此处仍用localhost，因为LS内部逻辑需要
      - NGINX_PROXY_PASS_AUTHORIZATION=true
      # --- [新增] 使用 Redis 存储 Session 以增强稳定性 ---
      - DJANGO_SESSION_ENGINE=django.contrib.sessions.backends.cache
      - LABEL_STUDIO_CACHE_BACKEND=django_redis.cache.RedisCache
      - REDIS_LOCATION=redis://redis:6379/1 # 使用内部服务名 redis, 并选择 1 号数据库以和 Celery (0号) 区分
      # --- [新增] 明确设置 Cookie 安全策略以适应 localhost 开发环境 ---
      - DJANGO_SESSION_COOKIE_SAMESITE=Lax
      - DJANGO_CSRF_COOKIE_SAMESITE=Lax
      - DJANGO_SESSION_COOKIE_SECURE=False
      - DJANGO_CSRF_COOKIE_SECURE=False
      # --- [新增] 明确指定受信任的来源，解决 Cookie 保存问题 ---
      - CSRF_TRUSTED_ORIGINS=http://localhost:8081
      # --- [新增] 允许用户自助注册和密码重置 ---
      - LABEL_STUDIO_SIGNUP_WITHOUT_INVITE=true

  authentik-server:
    image: ghcr.io/goauthentik/server:2025.6.4
    container_name: vss-authentik-server
    restart: unless-stopped
    command: server
    environment:
      AUTHENTIK_SECRET_KEY: ${AUTHENTIK_SECRET_KEY}
      AUTHENTIK_BOOTSTRAP_PASSWORD: ${AUTHENTIK_BOOTSTRAP_PASSWORD}
      # 连接到我们现有的 Redis 和 PostgreSQL
      AUTHENTIK_REDIS__HOST: redis
      AUTHENTIK_POSTGRESQL__HOST: db
      AUTHENTIK_POSTGRESQL__USER: ${POSTGRES_USER}
      AUTHENTIK_POSTGRESQL__NAME: ${AUTHENTIK_POSTGRESQL__NAME}
      AUTHENTIK_POSTGRESQL__PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - ./media_root/authentik/media:/media
      - ./configs/authentik/custom-templates:/templates
    ports:
      - "9000:9000"
      - "9443:9443"
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy

  authentik-worker:
    image: ghcr.io/goauthentik/server:2025.6.4
    container_name: vss-authentik-worker
    restart: unless-stopped
    command: worker
    environment:
      AUTHENTIK_SECRET_KEY: ${AUTHENTIK_SECRET_KEY}
      AUTHENTIK_BOOTSTRAP_PASSWORD: ${AUTHENTIK_BOOTSTRAP_PASSWORD}
      # 连接到我们现有的 Redis 和 PostgreSQL
      AUTHENTIK_REDIS__HOST: redis
      AUTHENTIK_POSTGRESQL__HOST: db
      AUTHENTIK_POSTGRESQL__USER: ${POSTGRES_USER}
      AUTHENTIK_POSTGRESQL__NAME: ${AUTHENTIK_POSTGRESQL__NAME}
      AUTHENTIK_POSTGRESQL__PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - ./media_root/authentik/media:/media
      - ./configs/authentik/custom-templates:/templates
      # 以下两个是可选的高级功能，我们可以先保留
      - /var/run/docker.sock:/var/run/docker.sock
      - ./configs/authentik/certs:/certs
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy

volumes:
  postgres_data:
  label_studio_data: